;You have eight colored balls: 1 black, 2 white, 2 red and 3 green.
; (situation3)
;the open list used by the search algorithms
(defvar *open* nil)

;the closed list used by the search algorithms
(defvar *closed* nil)


;Function: tofront
;Description: this function returns a list with the ith element moved to the front
;Parameters:
;i: the index of the element to move to the front
;l: the list
;Return: a list with the ith element moved to the front

(defun tofront (i l)
    (cons
        (nth i l)
        (append
            (butlast l (- (length l) i))
            (nthcdr (+ 1 i) l)
        )
    )
)

;Function: verfiy
;Description: this function checks a state to see if it fits the requirements
;Parameters:
;state: the state to verify
;Return: t if it works otherwise nil
(defun verify (state)
    (and
        ; 2 and 3 are not green
        (not (equal (nth 1 state) 'green))
        (not (equal (nth 2 state) 'green))

        ;4 and 8 are the same
        (equal (nth 3 state) (nth 7 state))

        ;1 and 7 are different
        (not (equal (nth 0 state) (nth 6 state)))

        ;6 and 7 are not red
        (not (equal (nth 5 state) 'red))
        (not (equal (nth 6 state) 'red))

        ;a white ball is not first or last
        (not (equal (nth 0 state) 'white))
        (not (equal (nth 7 state) 'white))

        ;left of red is green
        (leftOfRedIsGreen state)
        ;since the left of every red must be green red cannot be the first
        (not (equal (nth 0 state) 'red))
    )
)
;Function: leftOfRedIsGreen
;Description: this function checks a state to see if all red balls have a green one to their left
;note that this does not check to see if the first element is red
;Parameters:
;state: the state to check
;Return: t if all reds have green to the left (unless red is first)
(defun leftOfRedIsGreen (state)
    (cond
        ((>= 1 (length state)) t)
        ((and (equal 'red (second state)) (not (equal 'green (first state)))) nil)
        (t (leftOfRedIsGreen (cdr state)))
    )
)

;Function: make-children
;Description: this function returns a list of states where each is generated by the given function
;this function will also remove any states that are already in the *open* or *closed* lists
;Parameters:
;parent-state: this is the state that is passed to the generator function
;moves: a function that takes a single state as a parameter
;and returns a list of child states
;Return: a list of child nodes for the given state and generator
(defun make-children (parent-state moves)
    (mapcar
        (lambda (x)  x)
         (remove-if
             (lambda (x) (or
                (member x *open* :test #'equal)
                (member x *closed* :test #'equal)
            ))
            (remove nil (eval  (list moves (list 'quote parent-state))))
        )
    )
)

;Function: depth-first-search
;Description: uses the global *open* and *closed* lists
;to find a solution to the problem
;unlike a normal dfs this does not give a path
;Parameters:
;moves, a function that takes a state as a parameter and  returns the child states
(defun depth-first-search (moves)
    (cond
        ((>= 0 (length *open*))
            nil
        )
        ;((format t "~a~%" (car *open*)))
        ((verify (car *open*))
            (car *open*)
        )
        (T
            (setf *closed* (cons (car *open*) *closed*))
            (setf *open*
                (append
                    (make-children (car *open*) moves)
                    (cdr *open*)
                )
            )
            (depth-first-search moves)
        )
    )
)


;Function: situation3
;Description: returns a single solution to situation3
;Parameters:
;Returns:
;a state that satisfies the requirements, otherwise nil
(defun situation3 ()
    (setf *open* (list '(black white white red red green green green)))
    (setf *closed* nil)
     (depth-first-search 'children)
)

;Function: children
;Description: generates the children of a state
;the child states are each of the elements moved to the front
;Parameters:
;parent-state: this is the state to make children of
;Return: a list of child states for the given state
(defun children (parent-state)
    (list
        (tofront 1 parent-state)
        (tofront 2 parent-state)
        (tofront 3 parent-state)
        (tofront 4 parent-state)
        (tofront 6 parent-state)
        (tofront 7 parent-state)
    )
)
